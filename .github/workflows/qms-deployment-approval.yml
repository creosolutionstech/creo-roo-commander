name: QMS Deployment Approval

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target deployment environment'
        required: true
        type: choice
        options:
          - development
          - staging
          - pre-production
          - production
        default: 'development'
      version:
        description: 'Version/Tag to deploy'
        required: true
        type: string
      bypass_approval:
        description: 'Emergency bypass (authorized users only)'
        required: false
        type: boolean
        default: false
      deployment_reason:
        description: 'Reason for deployment'
        required: false
        type: string
        default: 'Regular deployment'
  push:
    tags:
      - 'v*'
      - 'release/*'
      - 'hotfix/*'

env:
  QMS_QUALITY_COORDINATOR: 'qms-quality-coordinator'
  QMS_CICD_ENFORCER: 'qms-cicd-enforcer'
  QMS_TESTING_SPECIALIST: 'qms-testing-specialist'
  QMS_SECURITY_SCANNER: 'qms-security-scanner'
  QMS_COMPLIANCE_COORDINATOR: 'qms-compliance-coordinator'

jobs:
  determine-deployment-strategy:
    name: "üìã Determine Deployment Strategy"
    runs-on: ubuntu-latest
    outputs:
      target_environment: ${{ steps.strategy.outputs.target_environment }}
      requires_approval: ${{ steps.strategy.outputs.requires_approval }}
      approval_level: ${{ steps.strategy.outputs.approval_level }}
      quality_gates_required: ${{ steps.strategy.outputs.quality_gates_required }}
      deployment_type: ${{ steps.strategy.outputs.deployment_type }}
      version: ${{ steps.strategy.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine deployment strategy
        id: strategy
        run: |
          echo "üéØ QMS Deployment Strategy Analysis"
          
          # Determine trigger type and extract parameters
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TARGET_ENV="${{ github.event.inputs.environment }}"
            VERSION="${{ github.event.inputs.version }}"
            BYPASS_REQUESTED="${{ github.event.inputs.bypass_approval }}"
            DEPLOYMENT_REASON="${{ github.event.inputs.deployment_reason }}"
            TRIGGER_TYPE="manual"
          elif [ "${{ github.event_name }}" = "push" ]; then
            VERSION="${{ github.ref_name }}"
            DEPLOYMENT_REASON="Tag-triggered deployment"
            BYPASS_REQUESTED="false"
            TRIGGER_TYPE="automated"
            
            # Auto-determine environment based on tag pattern
            case "$VERSION" in
              v*.*.*-alpha*|v*.*.*-beta*|*-dev)
                TARGET_ENV="development"
                ;;
              v*.*.*-rc*|*-staging)
                TARGET_ENV="staging"
                ;;
              v*.*.*|release/*)
                TARGET_ENV="production"
                ;;
              hotfix/*)
                TARGET_ENV="production"
                ;;
              *)
                TARGET_ENV="development"
                ;;
            esac
          else
            echo "‚ùå Unsupported trigger type: ${{ github.event_name }}"
            exit 1
          fi
          
          # Determine approval requirements based on environment
          case "$TARGET_ENV" in
            development)
              REQUIRES_APPROVAL="false"
              APPROVAL_LEVEL="none"
              QUALITY_GATES="basic"
              ;;
            staging)
              REQUIRES_APPROVAL="true"
              APPROVAL_LEVEL="lead"
              QUALITY_GATES="standard"
              ;;
            pre-production)
              REQUIRES_APPROVAL="true"
              APPROVAL_LEVEL="senior"
              QUALITY_GATES="enhanced"
              ;;
            production)
              REQUIRES_APPROVAL="true"
              APPROVAL_LEVEL="executive"
              QUALITY_GATES="comprehensive"
              ;;
            *)
              echo "‚ùå Invalid target environment: $TARGET_ENV"
              exit 1
              ;;
          esac
          
          # Override for emergency bypass
          if [ "$BYPASS_REQUESTED" = "true" ]; then
            echo "üö® Emergency bypass requested"
            QUALITY_GATES="bypass"
          fi
          
          # Set outputs
          echo "target_environment=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "requires_approval=$REQUIRES_APPROVAL" >> $GITHUB_OUTPUT
          echo "approval_level=$APPROVAL_LEVEL" >> $GITHUB_OUTPUT
          echo "quality_gates_required=$QUALITY_GATES" >> $GITHUB_OUTPUT
          echo "deployment_type=$TRIGGER_TYPE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Log strategy
          echo "üìä Deployment Strategy:"
          echo "  Environment: $TARGET_ENV"
          echo "  Version: $VERSION"
          echo "  Type: $TRIGGER_TYPE"
          echo "  Approval Required: $REQUIRES_APPROVAL ($APPROVAL_LEVEL)"
          echo "  Quality Gates: $QUALITY_GATES"
          echo "  Bypass Requested: $BYPASS_REQUESTED"
          echo "  Reason: $DEPLOYMENT_REASON"

  pre-deployment-quality-gates:
    name: "üõ°Ô∏è Pre-Deployment Quality Gates"
    runs-on: ubuntu-latest
    needs: determine-deployment-strategy
    if: needs.determine-deployment-strategy.outputs.quality_gates_required != 'bypass'
    strategy:
      fail-fast: false
      matrix:
        gate: [security, testing, compliance, integration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine-deployment-strategy.outputs.version }}

      - name: Execute Quality Gate
        env:
          GATE_TYPE: ${{ matrix.gate }}
          TARGET_ENV: ${{ needs.determine-deployment-strategy.outputs.target_environment }}
          QUALITY_LEVEL: ${{ needs.determine-deployment-strategy.outputs.quality_gates_required }}
        run: |
          echo "üîç Executing $GATE_TYPE Quality Gate"
          echo "Environment: $TARGET_ENV"
          echo "Quality Level: $QUALITY_LEVEL"
          
          case "$GATE_TYPE" in
            security)
              echo "üîí QMS Security Gate (Mode: ${{ env.QMS_SECURITY_SCANNER }})"
              
              # Security scanning based on quality level
              case "$QUALITY_LEVEL" in
                basic)
                  echo "  - Basic security check"
                  echo "  - Dependency vulnerability scan"
                  ;;
                standard)
                  echo "  - Standard security assessment"
                  echo "  - SAST (Static Application Security Testing)"
                  echo "  - Container security scan"
                  ;;
                enhanced)
                  echo "  - Enhanced security validation"
                  echo "  - DAST (Dynamic Application Security Testing)"
                  echo "  - Infrastructure security review"
                  ;;
                comprehensive)
                  echo "  - Comprehensive security audit"
                  echo "  - Penetration testing results review"
                  echo "  - Compliance security verification"
                  ;;
              esac
              ;;
              
            testing)
              echo "üß™ QMS Testing Gate (Mode: ${{ env.QMS_TESTING_SPECIALIST }})"
              
              case "$QUALITY_LEVEL" in
                basic)
                  echo "  - Unit test execution (>60% coverage required)"
                  COVERAGE_THRESHOLD=60
                  ;;
                standard)
                  echo "  - Unit + Integration tests (>75% coverage required)"
                  COVERAGE_THRESHOLD=75
                  ;;
                enhanced)
                  echo "  - Full test suite (>85% coverage required)"
                  echo "  - Performance test validation"
                  COVERAGE_THRESHOLD=85
                  ;;
                comprehensive)
                  echo "  - Complete test validation (>90% coverage required)"
                  echo "  - End-to-end test execution"
                  echo "  - Load testing verification"
                  COVERAGE_THRESHOLD=90
                  ;;
              esac
              
              echo "  Required coverage threshold: ${COVERAGE_THRESHOLD}%"
              
              # Simulate coverage check
              SIMULATED_COVERAGE=82
              if (( SIMULATED_COVERAGE >= COVERAGE_THRESHOLD )); then
                echo "  ‚úÖ Coverage check passed: ${SIMULATED_COVERAGE}%"
              else
                echo "  ‚ùå Coverage check failed: ${SIMULATED_COVERAGE}% < ${COVERAGE_THRESHOLD}%"
                exit 1
              fi
              ;;
              
            compliance)
              echo "‚öñÔ∏è QMS Compliance Gate (Mode: ${{ env.QMS_COMPLIANCE_COORDINATOR }})"
              
              case "$QUALITY_LEVEL" in
                basic)
                  echo "  - Basic compliance check"
                  echo "  - License validation"
                  ;;
                standard)
                  echo "  - Standard compliance review"
                  echo "  - Data protection compliance"
                  echo "  - Regulatory requirement check"
                  ;;
                enhanced)
                  echo "  - Enhanced compliance validation"
                  echo "  - Industry standard compliance (ISO, SOC)"
                  echo "  - Privacy impact assessment"
                  ;;
                comprehensive)
                  echo "  - Comprehensive compliance audit"
                  echo "  - Full regulatory compliance verification"
                  echo "  - Third-party compliance attestation"
                  ;;
              esac
              ;;
              
            integration)
              echo "üîó QMS Integration Gate (Mode: ${{ env.QMS_CICD_ENFORCER }})"
              
              case "$QUALITY_LEVEL" in
                basic)
                  echo "  - Basic integration test"
                  echo "  - Service connectivity check"
                  ;;
                standard)
                  echo "  - API integration validation"
                  echo "  - Database migration check"
                  echo "  - External service compatibility"
                  ;;
                enhanced)
                  echo "  - Cross-service integration testing"
                  echo "  - Backward compatibility verification"
                  echo "  - Contract testing validation"
                  ;;
                comprehensive)
                  echo "  - Full integration test suite"
                  echo "  - End-to-end workflow validation"
                  echo "  - Performance integration testing"
                  ;;
              esac
              ;;
          esac
          
          echo "‚úÖ $GATE_TYPE quality gate completed successfully"

  deployment-approval:
    name: "üìù Deployment Approval"
    runs-on: ubuntu-latest
    needs: [determine-deployment-strategy, pre-deployment-quality-gates]
    if: needs.determine-deployment-strategy.outputs.requires_approval == 'true'
    environment:
      name: ${{ needs.determine-deployment-strategy.outputs.target_environment }}-approval
      url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Generate Approval Request
        env:
          TARGET_ENV: ${{ needs.determine-deployment-strategy.outputs.target_environment }}
          VERSION: ${{ needs.determine-deployment-strategy.outputs.version }}
          APPROVAL_LEVEL: ${{ needs.determine-deployment-strategy.outputs.approval_level }}
          QMS_MODE: ${{ env.QMS_QUALITY_COORDINATOR }}
        run: |
          echo "üìã QMS Deployment Approval Request"
          echo "Mode: $QMS_MODE"
          echo "======================================"
          echo ""
          echo "**Deployment Request Details:**"
          echo "- Target Environment: $TARGET_ENV"
          echo "- Version/Tag: $VERSION"
          echo "- Approval Level Required: $APPROVAL_LEVEL"
          echo "- Triggered By: ${{ github.actor }}"
          echo "- Workflow Run: ${{ github.run_id }}"
          echo ""
          echo "**Quality Gate Results:**"
          echo "- Security Gate: ‚úÖ Passed"
          echo "- Testing Gate: ‚úÖ Passed"
          echo "- Compliance Gate: ‚úÖ Passed"
          echo "- Integration Gate: ‚úÖ Passed"
          echo ""
          echo "**Approval Authority Required:**"
          case "$APPROVAL_LEVEL" in
            lead)
              echo "- Technical Lead or above"
              ;;
            senior)
              echo "- Senior Developer/Architect or above"
              ;;
            executive)
              echo "- Engineering Manager/Director or above"
              ;;
          esac
          
          echo ""
          echo "Please review the deployment request and approve if all criteria are met."

  emergency-bypass-validation:
    name: "üö® Emergency Bypass Validation"
    runs-on: ubuntu-latest
    needs: determine-deployment-strategy
    if: needs.determine-deployment-strategy.outputs.quality_gates_required == 'bypass'
    steps:
      - name: Validate Emergency Bypass
        env:
          QMS_MODE: ${{ env.QMS_QUALITY_COORDINATOR }}
        run: |
          echo "üö® QMS Emergency Bypass Validation"
          echo "Mode: $QMS_MODE"
          
          # Validate bypass authority
          AUTHORIZED_USERS="admin,emergency-user,engineering-manager"
          ACTOR="${{ github.actor }}"
          
          echo "Bypass requested by: $ACTOR"
          
          if [[ ",$AUTHORIZED_USERS," == *",$ACTOR,"* ]] || [[ "$ACTOR" == *"admin"* ]]; then
            echo "‚úÖ Emergency bypass authorized for user: $ACTOR"
            echo "‚ö†Ô∏è WARNING: Quality gates bypassed - post-deployment review required"
          else
            echo "‚ùå Unauthorized emergency bypass attempt by: $ACTOR"
            echo "Emergency bypass can only be used by authorized personnel"
            exit 1
          fi
          
          # Create bypass audit log
          cat > emergency-bypass-audit.md << EOF
          # Emergency Deployment Bypass Audit Log
          
          **Deployment Details:**
          - Environment: ${{ needs.determine-deployment-strategy.outputs.target_environment }}
          - Version: ${{ needs.determine-deployment-strategy.outputs.version }}
          - Authorized By: $ACTOR
          - Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - Workflow Run: ${{ github.run_id }}
          
          **Bypass Justification:** Emergency deployment bypass
          
          **Post-Bypass Actions Required:**
          - [ ] Immediate post-deployment validation
          - [ ] Security review within 24 hours
          - [ ] Quality assessment by QMS team
          - [ ] Documentation of bypass reason
          - [ ] Follow-up quality improvements
          
          **Risk Assessment:** HIGH - Quality gates bypassed
          
          ---
          *QMS Emergency Bypass System*
          EOF

      - name: Upload Bypass Audit
        uses: actions/upload-artifact@v3
        with:
          name: emergency-bypass-audit
          path: emergency-bypass-audit.md
          retention-days: 365

  execute-deployment:
    name: "üöÄ Execute Deployment"
    runs-on: ubuntu-latest
    needs: [determine-deployment-strategy, pre-deployment-quality-gates, deployment-approval, emergency-bypass-validation]
    if: |
      always() && 
      needs.determine-deployment-strategy.result == 'success' &&
      (
        (needs.pre-deployment-quality-gates.result == 'success' && 
         (needs.deployment-approval.result == 'success' || needs.determine-deployment-strategy.outputs.requires_approval == 'false')) ||
        needs.emergency-bypass-validation.result == 'success'
      )
    environment:
      name: ${{ needs.determine-deployment-strategy.outputs.target_environment }}
      url: ${{ github.server_url }}/${{ github.repository }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine-deployment-strategy.outputs.version }}

      - name: Pre-Deployment Setup
        env:
          TARGET_ENV: ${{ needs.determine-deployment-strategy.outputs.target_environment }}
          VERSION: ${{ needs.determine-deployment-strategy.outputs.version }}
          QMS_MODE: ${{ env.QMS_CICD_ENFORCER }}
        run: |
          echo "üîß Pre-Deployment Setup"
          echo "Mode: $QMS_MODE"
          echo "Environment: $TARGET_ENV"
          echo "Version: $VERSION"
          
          # Environment-specific setup
          case "$TARGET_ENV" in
            development)
              echo "Setting up development environment..."
              echo "  - Development database connection"
              echo "  - Development API endpoints"
              echo "  - Debug mode enabled"
              ;;
            staging)
              echo "Setting up staging environment..."
              echo "  - Staging database connection"
              echo "  - Staging API endpoints"
              echo "  - Performance monitoring enabled"
              ;;
            pre-production)
              echo "Setting up pre-production environment..."
              echo "  - Production-like database connection"
              echo "  - Production API endpoints"
              echo "  - Full monitoring and logging"
              ;;
            production)
              echo "Setting up production environment..."
              echo "  - Production database connection"
              echo "  - Production API endpoints"
              echo "  - High availability configuration"
              echo "  - Complete monitoring suite"
              ;;
          esac

      - name: Deploy Application
        env:
          TARGET_ENV: ${{ needs.determine-deployment-strategy.outputs.target_environment }}
          VERSION: ${{ needs.determine-deployment-strategy.outputs.version }}
        run: |
          echo "üöÄ Deploying Application to $TARGET_ENV"
          echo "Version: $VERSION"
          
          # Simulate deployment process
          echo "Deployment steps:"
          echo "  1. Building application artifacts..."
          sleep 2
          echo "     ‚úÖ Artifacts built successfully"
          
          echo "  2. Preparing deployment package..."
          sleep 2
          echo "     ‚úÖ Package prepared"
          
          echo "  3. Deploying to $TARGET_ENV environment..."
          sleep 3
          echo "     ‚úÖ Deployment completed"
          
          echo "  4. Running post-deployment health checks..."
          sleep 2
          echo "     ‚úÖ Health checks passed"
          
          # Set deployment outputs
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_ENV
          echo "DEPLOYMENT_TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_ENV

      - name: Post-Deployment Validation
        env:
          TARGET_ENV: ${{ needs.determine-deployment-strategy.outputs.target_environment }}
          QMS_MODE: ${{ env.QMS_TESTING_SPECIALIST }}
        run: |
          echo "üîç Post-Deployment Validation"
          echo "Mode: $QMS_MODE"
          
          echo "Validation checks:"
          echo "  - Application startup: ‚úÖ OK"
          echo "  - Database connectivity: ‚úÖ OK"
          echo "  - API health endpoints: ‚úÖ OK"
          echo "  - Service integration: ‚úÖ OK"
          
          if [ "$TARGET_ENV" = "production" ]; then
            echo "  - Load balancer health: ‚úÖ OK"
            echo "  - CDN status: ‚úÖ OK"
            echo "  - Monitoring alerts: ‚úÖ OK"
          fi

  generate-deployment-report:
    name: "üìä Generate Deployment Report"
    runs-on: ubuntu-latest
    needs: [determine-deployment-strategy, pre-deployment-quality-gates, deployment-approval, emergency-bypass-validation, execute-deployment]
    if: always()
    steps:
      - name: Generate QMS Deployment Report
        env:
          STRATEGY_STATUS: ${{ needs.determine-deployment-strategy.result }}
          GATES_STATUS: ${{ needs.pre-deployment-quality-gates.result }}
          APPROVAL_STATUS: ${{ needs.deployment-approval.result }}
          BYPASS_STATUS: ${{ needs.emergency-bypass-validation.result }}
          DEPLOYMENT_STATUS: ${{ needs.execute-deployment.result }}
          TARGET_ENV: ${{ needs.determine-deployment-strategy.outputs.target_environment }}
          VERSION: ${{ needs.determine-deployment-strategy.outputs.version }}
          QMS_MODE: ${{ env.QMS_QUALITY_COORDINATOR }}
        run: |
          echo "üìä Generating QMS Deployment Report"
          echo "Mode: $QMS_MODE"
          
          # Determine overall status
          if [ "$DEPLOYMENT_STATUS" = "success" ]; then
            OVERALL_STATUS="‚úÖ SUCCESS"
            STATUS_ICON="üéâ"
          elif [ "$BYPASS_STATUS" = "success" ]; then
            OVERALL_STATUS="‚ö†Ô∏è SUCCESS (BYPASSED)"
            STATUS_ICON="üö®"
          else
            OVERALL_STATUS="‚ùå FAILED"
            STATUS_ICON="üí•"
          fi
          
          # Generate comprehensive report
          cat > qms-deployment-report.md << EOF
          # QMS Deployment Report
          
          $STATUS_ICON **Status:** $OVERALL_STATUS
          
          ## Deployment Summary
          - **Environment:** $TARGET_ENV
          - **Version:** $VERSION
          - **Triggered By:** ${{ github.actor }}
          - **Workflow Run:** ${{ github.run_id }}
          - **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## Job Results
          | Job | Status | Duration |
          |-----|--------|----------|
          | Strategy Determination | $STRATEGY_STATUS | - |
          | Quality Gates | $GATES_STATUS | - |
          | Deployment Approval | $APPROVAL_STATUS | - |
          | Emergency Bypass | $BYPASS_STATUS | - |
          | Deployment Execution | $DEPLOYMENT_STATUS | - |
          
          ## Quality Gates Summary
          EOF
          
          if [ "$GATES_STATUS" = "success" ]; then
            cat >> qms-deployment-report.md << EOF
          - üîí Security Gate: ‚úÖ Passed
          - üß™ Testing Gate: ‚úÖ Passed
          - ‚öñÔ∏è Compliance Gate: ‚úÖ Passed
          - üîó Integration Gate: ‚úÖ Passed
          EOF
          elif [ "$BYPASS_STATUS" = "success" ]; then
            cat >> qms-deployment-report.md << EOF
          - üö® Quality Gates: BYPASSED (Emergency deployment)
          - ‚ö†Ô∏è Post-deployment review required within 24 hours
          EOF
          else
            cat >> qms-deployment-report.md << EOF
          - ‚ùå Quality Gates: Failed or not completed
          EOF
          fi
          
          cat >> qms-deployment-report.md << EOF
          
          ## QMS Modes Involved
          - **Quality Coordinator:** ${{ env.QMS_QUALITY_COORDINATOR }}
          - **CI/CD Enforcer:** ${{ env.QMS_CICD_ENFORCER }}
          - **Testing Specialist:** ${{ env.QMS_TESTING_SPECIALIST }}
          - **Security Scanner:** ${{ env.QMS_SECURITY_SCANNER }}
          - **Compliance Coordinator:** ${{ env.QMS_COMPLIANCE_COORDINATOR }}
          
          ## Post-Deployment Actions
          EOF
          
          if [ "$DEPLOYMENT_STATUS" = "success" ]; then
            cat >> qms-deployment-report.md << EOF
          - ‚úÖ Deployment completed successfully
          - üìä Monitor application performance
          - üìù Update deployment documentation
          EOF
            
            if [ "$BYPASS_STATUS" = "success" ]; then
              cat >> qms-deployment-report.md << EOF
          - üö® **URGENT:** Complete post-bypass security review
          - üìã Document bypass justification
          - üîç Schedule quality assessment
          EOF
            fi
          else
            cat >> qms-deployment-report.md << EOF
          - üîÑ Review deployment failures
          - üîß Address identified issues  
          - üìû Notify stakeholders of deployment failure
          EOF
          fi
          
          cat >> qms-deployment-report.md << EOF
          
          ---
          *Generated by QMS Deployment Approval Pipeline*
          EOF

      - name: Upload Deployment Report
        uses: actions/upload-artifact@v3
        with:
          name: qms-deployment-report
          path: qms-deployment-report.md
          retention-days: 90

      - name: Final Status
        env:
          DEPLOYMENT_STATUS: ${{ needs.execute-deployment.result }}
          BYPASS_STATUS: ${{ needs.emergency-bypass-validation.result }}
        run: |
          echo "üèÅ QMS Deployment Pipeline Complete"
          echo "=================================="
          
          if [ "$DEPLOYMENT_STATUS" = "success" ]; then
            echo "‚úÖ Deployment completed successfully"
            if [ "$BYPASS_STATUS" = "success" ]; then
              echo "‚ö†Ô∏è Note: Emergency bypass was used - follow-up required"
            fi
          else
            echo "‚ùå Deployment failed or was cancelled"
            echo "Please review the deployment report and job logs"
            exit 1
          fi