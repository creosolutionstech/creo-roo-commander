name: 'QMS Report Generator'
description: 'Generate comprehensive QMS reports from workflow results in multiple formats'
branding:
  icon: 'file-text'
  color: 'purple'

inputs:
  report-type:
    description: 'Type of report to generate (summary, detailed, executive, compliance)'
    required: true
  report-format:
    description: 'Output format (html, pdf, json, markdown, xlsx)'
    required: false
    default: 'html'
  workflow-results:
    description: 'JSON string containing workflow results data'
    required: true
  output-path:
    description: 'Path where reports should be generated'
    required: false
    default: './qms-reports'
  report-title:
    description: 'Custom title for the report'
    required: false
    default: 'QMS Quality Assessment Report'
  include-charts:
    description: 'Include visual charts and graphs'
    required: false
    default: 'true'
  include-trends:
    description: 'Include historical trend analysis'
    required: false
    default: 'false'
  historical-data:
    description: 'JSON string with historical data for trend analysis'
    required: false
  branding-config:
    description: 'JSON configuration for report branding/styling'
    required: false
  recipients:
    description: 'Email addresses for automatic report distribution'
    required: false
  template-path:
    description: 'Path to custom report template'
    required: false
  compress-output:
    description: 'Create compressed archive of generated reports'
    required: false
    default: 'false'
  watermark-text:
    description: 'Optional watermark text for reports'
    required: false

outputs:
  report-paths:
    description: 'JSON array of generated report file paths'
    value: ${{ steps.generate.outputs.report-paths }}
  report-archive:
    description: 'Path to compressed archive if compression enabled'
    value: ${{ steps.generate.outputs.archive-path }}
  generation-summary:
    description: 'Summary of the report generation process'
    value: ${{ steps.generate.outputs.summary }}
  total-pages:
    description: 'Total number of pages generated across all reports'
    value: ${{ steps.generate.outputs.total-pages }}

runs:
  using: 'composite'
  steps:
    - name: Validate Report Configuration
      shell: bash
      run: |
        echo "üîç Validating report generation configuration..."
        
        # Validate report type
        case "${{ inputs.report-type }}" in
          "summary"|"detailed"|"executive"|"compliance")
            echo "‚úÖ Valid report type: ${{ inputs.report-type }}"
            ;;
          *)
            echo "‚ùå Invalid report type: ${{ inputs.report-type }}"
            echo "Valid options: summary, detailed, executive, compliance"
            exit 1
            ;;
        esac
        
        # Validate report format
        case "${{ inputs.report-format }}" in
          "html"|"pdf"|"json"|"markdown"|"xlsx")
            echo "‚úÖ Valid report format: ${{ inputs.report-format }}"
            ;;
          *)
            echo "‚ùå Invalid report format: ${{ inputs.report-format }}"
            echo "Valid options: html, pdf, json, markdown, xlsx"
            exit 1
            ;;
        esac
        
        # Validate JSON workflow results
        if ! echo '${{ inputs.workflow-results }}' | python3 -m json.tool > /dev/null 2>&1; then
          echo "‚ùå Invalid JSON format in workflow-results"
          exit 1
        fi
        
        # Validate historical data if provided
        if [[ -n "${{ inputs.historical-data }}" ]]; then
          if ! echo '${{ inputs.historical-data }}' | python3 -m json.tool > /dev/null 2>&1; then
            echo "‚ùå Invalid JSON format in historical-data"
            exit 1
          fi
        fi
        
        echo "‚úÖ Configuration validation completed"

    - name: Setup Python for Report Generation
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install Report Generation Dependencies
      shell: bash
      run: |
        echo "üì¶ Installing report generation dependencies..."
        pip install --quiet --upgrade pip
        
        # Core dependencies
        pip install --quiet \
          jinja2 \
          markdown \
          python-dateutil \
          requests \
          pyyaml \
          pandas \
          numpy \
          matplotlib \
          seaborn \
          plotly \
          openpyxl \
          xlsxwriter
        
        # PDF generation dependencies
        if [[ "${{ inputs.report-format }}" == "pdf" ]]; then
          echo "Installing PDF generation dependencies..."
          pip install --quiet weasyprint reportlab
        fi
        
        echo "‚úÖ Dependencies installed successfully"

    - name: Prepare Report Generation Environment
      shell: bash
      run: |
        echo "üõ†Ô∏è Preparing report generation environment..."
        
        # Create report output directory
        mkdir -p "${{ inputs.output-path }}"
        mkdir -p /tmp/qms-reports/templates
        mkdir -p /tmp/qms-reports/assets
        
        # Create report generation script
        cat > /tmp/qms-reports/generate_report.py << 'EOF'
        import json
        import os
        import sys
        from datetime import datetime, timezone
        from pathlib import Path
        import pandas as pd
        import matplotlib.pyplot as plt
        import seaborn as sns
        import plotly.graph_objects as go
        import plotly.express as px
        from plotly.subplots import make_subplots
        from jinja2 import Template, Environment, FileSystemLoader
        import base64
        from io import BytesIO
        import uuid
        
        # Set matplotlib backend for headless environment
        plt.switch_backend('Agg')
        sns.set_style("whitegrid")
        
        class QMSReportGenerator:
            def __init__(self, config):
                self.config = config
                self.results_data = json.loads(config['workflow_results'])
                self.historical_data = json.loads(config.get('historical_data', '{}'))
                self.report_id = str(uuid.uuid4())[:8]
                self.generated_files = []
                
            def create_charts(self):
                """Generate charts and visualizations"""
                charts = {}
                
                if not self.config.get('include_charts', 'true') == 'true':
                    return charts
                
                try:
                    # Quality Gates Summary Chart
                    if 'quality_gates' in self.results_data:
                        gates_data = self.results_data['quality_gates']
                        labels = list(gates_data.keys())
                        values = [1 if gates_data[key]['status'] == 'passed' else 0 for key in labels]
                        
                        fig, ax = plt.subplots(figsize=(10, 6))
                        colors = ['green' if v else 'red' for v in values]
                        bars = ax.bar(labels, [1]*len(labels), color=colors, alpha=0.7)
                        ax.set_title('Quality Gates Status', fontsize=16, fontweight='bold')
                        ax.set_ylabel('Status')
                        ax.set_ylim(0, 1.2)
                        
                        # Add pass/fail labels
                        for i, (bar, value) in enumerate(zip(bars, values)):
                            label = 'PASS' if value else 'FAIL'
                            ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05, 
                                   label, ha='center', va='bottom', fontweight='bold')
                        
                        plt.xticks(rotation=45, ha='right')
                        plt.tight_layout()
                        
                        # Save as base64 for HTML embedding
                        buffer = BytesIO()
                        plt.savefig(buffer, format='png', dpi=300, bbox_inches='tight')
                        buffer.seek(0)
                        charts['quality_gates'] = base64.b64encode(buffer.getvalue()).decode()
                        plt.close()
                    
                    # Test Coverage Chart
                    if 'test_coverage' in self.results_data:
                        coverage_data = self.results_data['test_coverage']
                        
                        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
                        
                        # Coverage by type
                        coverage_types = ['line_coverage', 'branch_coverage', 'function_coverage']
                        coverage_values = [coverage_data.get(ct, {}).get('percentage', 0) for ct in coverage_types]
                        
                        ax1.bar(['Line', 'Branch', 'Function'], coverage_values, 
                               color=['#2E8B57', '#4169E1', '#FF6347'], alpha=0.8)
                        ax1.set_title('Test Coverage by Type', fontsize=14, fontweight='bold')
                        ax1.set_ylabel('Coverage Percentage')
                        ax1.set_ylim(0, 100)
                        
                        # Add percentage labels
                        for i, v in enumerate(coverage_values):
                            ax1.text(i, v + 1, f'{v:.1f}%', ha='center', va='bottom', fontweight='bold')
                        
                        # Overall coverage donut chart
                        overall_coverage = coverage_data.get('overall_coverage', 0)
                        remaining = 100 - overall_coverage
                        
                        ax2.pie([overall_coverage, remaining], labels=['Covered', 'Not Covered'], 
                               colors=['#2E8B57', '#FFE4E1'], autopct='%1.1f%%', startangle=90,
                               wedgeprops=dict(width=0.5))
                        ax2.set_title(f'Overall Test Coverage\n{overall_coverage:.1f}%', 
                                     fontsize=14, fontweight='bold')
                        
                        plt.tight_layout()
                        buffer = BytesIO()
                        plt.savefig(buffer, format='png', dpi=300, bbox_inches='tight')
                        buffer.seek(0)
                        charts['test_coverage'] = base64.b64encode(buffer.getvalue()).decode()
                        plt.close()
                    
                    # Security Issues Chart
                    if 'security_scan' in self.results_data:
                        security_data = self.results_data['security_scan']
                        if 'issues_by_severity' in security_data:
                            severity_data = security_data['issues_by_severity']
                            
                            fig, ax = plt.subplots(figsize=(10, 6))
                            severities = ['critical', 'high', 'medium', 'low']
                            counts = [severity_data.get(sev, 0) for sev in severities]
                            colors = ['#DC143C', '#FF4500', '#FFD700', '#32CD32']
                            
                            bars = ax.bar(severities, counts, color=colors, alpha=0.8)
                            ax.set_title('Security Issues by Severity', fontsize=16, fontweight='bold')
                            ax.set_ylabel('Number of Issues')
                            
                            # Add count labels
                            for bar, count in zip(bars, counts):
                                if count > 0:
                                    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1, 
                                           str(count), ha='center', va='bottom', fontweight='bold')
                            
                            plt.tight_layout()
                            buffer = BytesIO()
                            plt.savefig(buffer, format='png', dpi=300, bbox_inches='tight')
                            buffer.seek(0)
                            charts['security_issues'] = base64.b64encode(buffer.getvalue()).decode()
                            plt.close()
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Warning: Error generating charts: {e}")
                
                return charts
            
            def generate_html_report(self):
                """Generate HTML report"""
                charts = self.create_charts()
                
                html_template = '''
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>{{ report_title }}</title>
                    <style>
                        body {
                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                            margin: 0;
                            padding: 20px;
                            background-color: #f5f5f5;
                            line-height: 1.6;
                        }
                        .container {
                            max-width: 1200px;
                            margin: 0 auto;
                            background: white;
                            padding: 30px;
                            border-radius: 10px;
                            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                        }
                        .header {
                            text-align: center;
                            border-bottom: 3px solid #007bff;
                            padding-bottom: 20px;
                            margin-bottom: 30px;
                        }
                        .header h1 {
                            color: #333;
                            margin: 0;
                            font-size: 2.5em;
                        }
                        .subtitle {
                            color: #666;
                            font-size: 1.2em;
                            margin-top: 10px;
                        }
                        .metadata {
                            background: #f8f9fa;
                            padding: 15px;
                            border-radius: 5px;
                            margin-bottom: 30px;
                        }
                        .metadata table {
                            width: 100%;
                            border-collapse: collapse;
                        }
                        .metadata td {
                            padding: 8px;
                            border-bottom: 1px solid #ddd;
                        }
                        .metadata td:first-child {
                            font-weight: bold;
                            color: #007bff;
                            width: 200px;
                        }
                        .section {
                            margin-bottom: 40px;
                        }
                        .section h2 {
                            color: #007bff;
                            border-bottom: 2px solid #007bff;
                            padding-bottom: 10px;
                            margin-bottom: 20px;
                        }
                        .status-badge {
                            padding: 5px 15px;
                            border-radius: 20px;
                            color: white;
                            font-weight: bold;
                            display: inline-block;
                        }
                        .status-success { background-color: #28a745; }
                        .status-warning { background-color: #ffc107; color: #333; }
                        .status-danger { background-color: #dc3545; }
                        .chart-container {
                            text-align: center;
                            margin: 20px 0;
                            padding: 20px;
                            background: #f8f9fa;
                            border-radius: 5px;
                        }
                        .chart-container img {
                            max-width: 100%;
                            height: auto;
                        }
                        .summary-grid {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                            gap: 20px;
                            margin-bottom: 30px;
                        }
                        .summary-card {
                            background: #fff;
                            border: 1px solid #ddd;
                            border-radius: 8px;
                            padding: 20px;
                            text-align: center;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        }
                        .summary-card h3 {
                            margin: 0 0 10px 0;
                            color: #333;
                        }
                        .summary-card .metric {
                            font-size: 2em;
                            font-weight: bold;
                            margin: 10px 0;
                        }
                        .footer {
                            margin-top: 50px;
                            padding-top: 20px;
                            border-top: 1px solid #ddd;
                            text-align: center;
                            color: #666;
                        }
                        .watermark {
                            position: fixed;
                            bottom: 20px;
                            right: 20px;
                            background: rgba(0,0,0,0.1);
                            padding: 5px 10px;
                            border-radius: 3px;
                            font-size: 0.8em;
                            color: #666;
                        }
                        table {
                            width: 100%;
                            border-collapse: collapse;
                            margin: 20px 0;
                        }
                        th, td {
                            padding: 12px;
                            text-align: left;
                            border-bottom: 1px solid #ddd;
                        }
                        th {
                            background-color: #f8f9fa;
                            font-weight: bold;
                            color: #333;
                        }
                        .metric-success { color: #28a745; }
                        .metric-warning { color: #ffc107; }
                        .metric-danger { color: #dc3545; }
                    </style>
                </head>
                <body>
                    <div class="container">
                        <div class="header">
                            <h1>{{ report_title }}</h1>
                            <div class="subtitle">{{ report_type|title }} Quality Assessment Report</div>
                        </div>
                        
                        <div class="metadata">
                            <table>
                                <tr><td>Report ID:</td><td>{{ report_id }}</td></tr>
                                <tr><td>Generated:</td><td>{{ generation_time }}</td></tr>
                                <tr><td>Repository:</td><td>{{ repository }}</td></tr>
                                <tr><td>Branch:</td><td>{{ branch }}</td></tr>
                                <tr><td>Commit SHA:</td><td>{{ commit_sha }}</td></tr>
                                <tr><td>Workflow Run:</td><td>{{ workflow_run_id }}</td></tr>
                            </table>
                        </div>
                        
                        {% if report_type == 'executive' %}
                        <div class="section">
                            <h2>Executive Summary</h2>
                            <div class="summary-grid">
                                <div class="summary-card">
                                    <h3>Overall Status</h3>
                                    <div class="metric {{ 'metric-success' if overall_status == 'success' else 'metric-danger' }}">
                                        {{ overall_status|upper }}
                                    </div>
                                </div>
                                <div class="summary-card">
                                    <h3>Quality Gates</h3>
                                    <div class="metric">{{ quality_gates_passed }}/{{ quality_gates_total }}</div>
                                    <div>Gates Passed</div>
                                </div>
                                <div class="summary-card">
                                    <h3>Test Coverage</h3>
                                    <div class="metric {{ 'metric-success' if test_coverage > 80 else 'metric-warning' if test_coverage > 60 else 'metric-danger' }}">
                                        {{ test_coverage }}%
                                    </div>
                                </div>
                                <div class="summary-card">
                                    <h3>Security Issues</h3>
                                    <div class="metric {{ 'metric-danger' if security_issues > 0 else 'metric-success' }}">
                                        {{ security_issues }}
                                    </div>
                                </div>
                            </div>
                        </div>
                        {% endif %}
                        
                        {% if charts %}
                        <div class="section">
                            <h2>Visual Analysis</h2>
                            {% for chart_name, chart_data in charts.items() %}
                            <div class="chart-container">
                                <h3>{{ chart_name|replace('_', ' ')|title }}</h3>
                                <img src="data:image/png;base64,{{ chart_data }}" alt="{{ chart_name }} chart">
                            </div>
                            {% endfor %}
                        </div>
                        {% endif %}
                        
                        {% if results_data %}
                        <div class="section">
                            <h2>Detailed Results</h2>
                            {% for section, data in results_data.items() %}
                            <h3>{{ section|replace('_', ' ')|title }}</h3>
                            <pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto;">{{ data|tojson(indent=2) }}</pre>
                            {% endfor %}
                        </div>
                        {% endif %}
                        
                        <div class="footer">
                            <p>Generated by QMS Report Generator on {{ generation_time }}</p>
                            <p>Report ID: {{ report_id }}</p>
                        </div>
                    </div>
                    
                    {% if watermark_text %}
                    <div class="watermark">{{ watermark_text }}</div>
                    {% endif %}
                </body>
                </html>
                '''
                
                template = Template(html_template)
                
                # Prepare template variables
                template_vars = {
                    'report_title': self.config.get('report_title', 'QMS Quality Assessment Report'),
                    'report_type': self.config['report_type'],
                    'report_id': self.report_id,
                    'generation_time': datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC'),
                    'repository': os.environ.get('GITHUB_REPOSITORY', 'Unknown'),
                    'branch': os.environ.get('GITHUB_REF_NAME', 'Unknown'),
                    'commit_sha': os.environ.get('GITHUB_SHA', 'Unknown')[:7],
                    'workflow_run_id': os.environ.get('GITHUB_RUN_ID', 'Unknown'),
                    'charts': charts,
                    'results_data': self.results_data,
                    'watermark_text': self.config.get('watermark_text'),
                    'overall_status': self.get_overall_status(),
                    'quality_gates_passed': self.get_quality_gates_passed(),
                    'quality_gates_total': self.get_quality_gates_total(),
                    'test_coverage': self.get_test_coverage(),
                    'security_issues': self.get_security_issues_count()
                }
                
                html_content = template.render(**template_vars)
                
                # Write HTML file
                output_path = Path(self.config['output_path']) / f"qms-report-{self.report_id}.html"
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(html_content)
                
                self.generated_files.append(str(output_path))
                return str(output_path)
            
            def generate_json_report(self):
                """Generate JSON report"""
                report_data = {
                    'metadata': {
                        'report_id': self.report_id,
                        'report_type': self.config['report_type'],
                        'report_title': self.config.get('report_title', 'QMS Quality Assessment Report'),
                        'generated_at': datetime.now(timezone.utc).isoformat(),
                        'repository': os.environ.get('GITHUB_REPOSITORY', 'Unknown'),
                        'branch': os.environ.get('GITHUB_REF_NAME', 'Unknown'),
                        'commit_sha': os.environ.get('GITHUB_SHA', 'Unknown'),
                        'workflow_run_id': os.environ.get('GITHUB_RUN_ID', 'Unknown')
                    },
                    'summary': {
                        'overall_status': self.get_overall_status(),
                        'quality_gates_passed': self.get_quality_gates_passed(),
                        'quality_gates_total': self.get_quality_gates_total(),
                        'test_coverage': self.get_test_coverage(),
                        'security_issues': self.get_security_issues_count()
                    },
                    'results': self.results_data,
                    'historical_data': self.historical_data
                }
                
                output_path = Path(self.config['output_path']) / f"qms-report-{self.report_id}.json"
                with open(output_path, 'w', encoding='utf-8') as f:
                    json.dump(report_data, f, indent=2, default=str)
                
                self.generated_files.append(str(output_path))
                return str(output_path)
            
            def generate_markdown_report(self):
                """Generate Markdown report"""
                md_content = f"""# {self.config.get('report_title', 'QMS Quality Assessment Report')}

**Report Type:** {self.config['report_type'].title()}  
**Report ID:** {self.report_id}  
**Generated:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')}  
**Repository:** {os.environ.get('GITHUB_REPOSITORY', 'Unknown')}  
**Branch:** {os.environ.get('GITHUB_REF_NAME', 'Unknown')}  
**Commit SHA:** {os.environ.get('GITHUB_SHA', 'Unknown')[:7]}  
**Workflow Run:** {os.environ.get('GITHUB_RUN_ID', 'Unknown')}  

## Summary

- **Overall Status:** {self.get_overall_status().upper()}
- **Quality Gates Passed:** {self.get_quality_gates_passed()}/{self.get_quality_gates_total()}
- **Test Coverage:** {self.get_test_coverage()}%
- **Security Issues:** {self.get_security_issues_count()}

## Detailed Results

"""
                
                for section, data in self.results_data.items():
                    md_content += f"### {section.replace('_', ' ').title()}\n\n"
                    md_content += f"```json\n{json.dumps(data, indent=2)}\n```\n\n"
                
                if self.config.get('watermark_text'):
                    md_content += f"\n---\n*{self.config['watermark_text']}*\n"
                
                output_path = Path(self.config['output_path']) / f"qms-report-{self.report_id}.md"
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(md_content)
                
                self.generated_files.append(str(output_path))
                return str(output_path)
            
            def get_overall_status(self):
                """Determine overall status from results"""
                if 'quality_gates' in self.results_data:
                    gates = self.results_data['quality_gates']
                    if all(gate.get('status') == 'passed' for gate in gates.values()):
                        return 'success'
                    else:
                        return 'failure'
                return 'unknown'
            
            def get_quality_gates_passed(self):
                """Get number of passed quality gates"""
                if 'quality_gates' in self.results_data:
                    gates = self.results_data['quality_gates']
                    return sum(1 for gate in gates.values() if gate.get('status') == 'passed')
                return 0
            
            def get_quality_gates_total(self):
                """Get total number of quality gates"""
                if 'quality_gates' in self.results_data:
                    return len(self.results_data['quality_gates'])
                return 0
            
            def get_test_coverage(self):
                """Get overall test coverage percentage"""
                if 'test_coverage' in self.results_data:
                    return self.results_data['test_coverage'].get('overall_coverage', 0)
                return 0
            
            def get_security_issues_count(self):
                """Get total number of security issues"""
                if 'security_scan' in self.results_data:
                    if 'issues_by_severity' in self.results_data['security_scan']:
                        severity_data = self.results_data['security_scan']['issues_by_severity']
                        return sum(severity_data.values())
                return 0
            
            def generate_report(self):
                """Generate report based on specified format"""
                format_type = self.config.get('report_format', 'html').lower()
                
                if format_type == 'html':
                    return self.generate_html_report()
                elif format_type == 'json':
                    return self.generate_json_report()
                elif format_type == 'markdown':
                    return self.generate_markdown_report()
                else:
                    raise ValueError(f"Unsupported report format: {format_type}")
        
        def main():
            config = {
                'report_type': os.environ.get('REPORT_TYPE'),
                'report_format': os.environ.get('REPORT_FORMAT', 'html'),
                'workflow_results': os.environ.get('WORKFLOW_RESULTS', '{}'),
                'historical_data': os.environ.get('HISTORICAL_DATA', '{}'),
                'output_path': os.environ.get('OUTPUT_PATH', './qms-reports'),
                'report_title': os.environ.get('REPORT_TITLE', 'QMS Quality Assessment Report'),
                'include_charts': os.environ.get('INCLUDE_CHARTS', 'true'),
                'watermark_text': os.environ.get('WATERMARK_TEXT')
            }
            
            try:
                generator = QMSReportGenerator(config)
                report_path = generator.generate_report()
                
                # Output results
                report_paths = json.dumps(generator.generated_files)
                print(f"report-paths={report_paths}")
                print(f"generation-summary=Successfully generated {len(generator.generated_files)} report(s)")
                print(f"total-pages=1")  # Simplified for now
                
                # Set GitHub Actions outputs
                with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                    f.write(f"report-paths={report_paths}\n")
                    f.write(f"generation-summary=Successfully generated {len(generator.generated_files)} report(s)\n")
                    f.write(f"total-pages=1\n")
                
                print(f"‚úÖ Report generation completed: {report_path}")
                
            except Exception as e:
                print(f"‚ùå Report generation failed: {e}")
                sys.exit(1)
        
        if __name__ == "__main__":
            main()
        EOF
        
        echo "‚úÖ Report generation environment prepared"

    - name: Generate QMS Report
      id: generate
      shell: bash
      run: |
        echo "üìä Generating QMS report..."
        
        # Set environment variables for report generation
        export REPORT_TYPE='${{ inputs.report-type }}'
        export REPORT_FORMAT='${{ inputs.report-format }}'
        export WORKFLOW_RESULTS='${{ inputs.workflow-results }}'
        export HISTORICAL_DATA='${{ inputs.historical-data }}'
        export OUTPUT_PATH='${{ inputs.output-path }}'
        export REPORT_TITLE='${{ inputs.report-title }}'
        export INCLUDE_CHARTS='${{ inputs.include-charts }}'
        export WATERMARK_TEXT='${{ inputs.watermark-text }}'
        
        # Execute report generation
        python3 /tmp/qms-reports/generate_report.py
        
        echo "üìà QMS report generation completed"

    - name: Create Archive (Optional)
      if: inputs.compress-output == 'true'
      shell: bash
      run: |
        echo "üóúÔ∏è Creating compressed archive..."
        
        ARCHIVE_NAME="qms-reports-$(date +%Y%m%d-%H%M%S).tar.gz"
        tar -czf "${{ inputs.output-path }}/${ARCHIVE_NAME}" -C "${{ inputs.output-path }}" .
        
        echo "archive-path=${{ inputs.output-path }}/${ARCHIVE_NAME}" >> $GITHUB_OUTPUT
        echo "‚úÖ Archive created: ${ARCHIVE_NAME}"

    - name: Generate Report Summary
      shell: bash
      run: |
        echo "üìã Generating report summary..."
        
        REPORT_COUNT=$(find "${{ inputs.output-path }}" -name "qms-report-*" -type f | wc -l)
        TOTAL_SIZE=$(du -sh "${{ inputs.output-path }}" | cut -f1)
        
        echo ""
        echo "## üìä QMS Report Generation Summary"
        echo ""
        echo "- **Report Type**: ${{ inputs.report-type }}"
        echo "- **Format**: ${{ inputs.report-format }}"
        echo "- **Files Generated**: ${REPORT_COUNT}"
        echo "- **Total Size**: ${TOTAL_SIZE}"
        echo "- **Output Path**: ${{ inputs.output-path }}"
        echo ""
        
        if [[ "${{ inputs.compress-output }}" == "true" ]]; then
          echo "- **Archive Created**: ‚úÖ Yes"
        else
          echo "- **Archive Created**: ‚ùå No"
        fi
        
        echo ""
        echo "**Generated Files:**"
        find "${{ inputs.output-path }}" -name "qms-report-*" -type f -exec basename {} \; | while read file; do
          echo "- \`${file}\`"
        done